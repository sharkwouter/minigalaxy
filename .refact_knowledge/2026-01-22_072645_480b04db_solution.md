---
id: "514957d4-95da-44f7-9e76-66356f6beda3"
title: "Rename 'translator' to 'compatibility layer' with shims"
kind: decision
created: 2026-01-22
updated: 2026-01-22
review_after: 2026-04-22
status: active
tags: ["compatibility", "migration", "minigalaxy", "planning", "refactoring", "strategic", "terminology"]
filenames: ["/home/mateus/minigalaxy/data/ui/properties.ui", "/home/mateus/minigalaxy/minigalaxy/config.py", "/home/mateus/minigalaxy/minigalaxy/game.py", "/home/mateus/minigalaxy/minigalaxy/launcher.py", "/home/mateus/minigalaxy/minigalaxy/translator.py", "/home/mateus/minigalaxy/minigalaxy/ui/properties.py", "data/ui/properties.ui", "minigalaxy/compatibility_layer.py", "minigalaxy/config.py", "minigalaxy/game.py", "minigalaxy/launcher.py", "minigalaxy/translator.py", "minigalaxy/ui/properties.py"]
---

# Solution
## Problem identified (from the conversation + provided files)

The UI already says **“OS/ISA Compatibility Layer”**, but the codebase still uses **“translator”** terminology in many places:

- Module + types: `minigalaxy/translator.py` (`Translator`, `TranslatorType`)
- Config schema + API: `Config.translators`, `Config.game_translators`, `get_game_translators()`, etc. (`minigalaxy/config.py`)
- Game helpers: `get_selected_translators()` / `set_selected_translators()` (`minigalaxy/game.py`)
- Launcher plumbing: `add_translators_to_command()` + keys like `os_translator_exec`, `isa_translator_exec` (`minigalaxy/launcher.py`)
- Properties dialog uses IDs and fields like `button_properties_os_translator` (`data/ui/properties.ui`, `minigalaxy/ui/properties.py`)

Maintainer wants terminology consistent: “compatibility layer” instead of “translator”.

The main risk is **breaking existing user data**:
- `config.json` currently stores keys like `translators` and `game_translators`
- per-game JSON stores keys like `os_translator_exec`, `isa_translator_exec`, and legacy `custom_wine`

So the solution must **rename terminology without breaking existing installs**, and ideally remain downgrade-friendly.

---

## Robust, complete solution (recommended): “New names + compatibility shims + data migration”

### 1) Introduce canonical “compatibility layer” module, keep `translator.py` as a shim
Create a new module:

- `minigalaxy/compatibility_layer.py` (new, canonical)
  - `CompatibilityLayerType` (replaces `TranslatorType`)
  - `CompatibilityLayer` (replaces `Translator`)

Then turn the old module into a compatibility re-export:

- `minigalaxy/translator.py` (keep file, but deprecate)
  - `from .compatibility_layer import CompatibilityLayer as Translator`
  - `from .compatibility_layer import CompatibilityLayerType as TranslatorType`

**Corner case handled:** any external imports (or remaining internal imports you missed) won’t crash immediately.

---

### 2) Migrate config keys safely, while remaining downgrade-friendly
In `minigalaxy/config.py`, add new canonical properties/methods:

- `compatibility_layers` (new) ← reads from `compatibility_layers` else falls back to `translators`
- `game_compatibility_layers` (new) ← reads from `game_compatibility_layers` else falls back to `game_translators`

When writing, **write both** keys for a while:
- set both `"compatibility_layers"` and `"translators"`
- set both `"game_compatibility_layers"` and `"game_translators"`

Also add method aliases:
- `add_compatibility_layer()` (new) + keep `add_translator()` calling it
- `set_game_compatibility_layers()` (new) + keep `set_game_translators()` calling it
- same for getters/removers

**Corner cases handled:**
- Existing users upgrading: new code reads old keys.
- Users downgrading after upgrade: old app still sees old keys, because you continue writing them.
- Partial config / corrupted config: existing load error handling stays.

---

### 3) Migrate per-game stored keys with “read-new, fallback-old, write-both”
Right now `launcher.py` and `properties.py` rely on:
- `os_translator_exec`
- `isa_translator_exec`
- legacy: `custom_wine`

If you rename stored keys to:
- `os_compat_layer_exec`
- `isa_compat_layer_exec`

…you must keep compatibility.

**Best practice:** centralize this in `minigalaxy/game.py` so all callers use one API:

Add helpers:

- `get_os_compat_layer_exec()`:
  - return first non-empty of:
    - `os_compat_layer_exec`
    - `os_translator_exec`
    - `custom_wine`
- `set_os_compat_layer_exec(path_or_empty)`:
  - write to all 3 keys (new + old + legacy) for downgrade safety

Same pattern for ISA:
- `isa_compat_layer_exec` ↔ fallback to `isa_translator_exec`
- and write both on save

**Important corner case fix:** avoid storing `None` for these keys.
In your current `Properties.on_button_properties_reset_os_clicked()` you set:
- `self.game.set_info("os_translator_exec", None)`
- `self.game.set_info("custom_wine", None)`

That can leak `None` into JSON and later create weird type issues. Prefer `""` consistently for “unset”.

---

### 4) Update launcher terminology without breaking callers
In `minigalaxy/launcher.py`:

- Rename `add_translators_to_command()` → `add_compatibility_layers_to_command()`
- Keep old function name as wrapper:

```py
def add_translators_to_command(game, exe_cmd):
    # backwards compatible wrapper
    return add_compatibility_layers_to_command(game, exe_cmd)
```

Then update the implementation to read from `game.get_os_compat_layer_exec()` / `get_isa_compat_layer_exec()` (the new centralized helpers).

Also update docstrings (“translator” → “compatibility layer”) in:
- `get_wine_path()`
- `config_game()`, `regedit_game()`

---

### 5) UI IDs: optional, but if you rename them, do it with care
Renaming Glade IDs is optional (it’s internal), but if you want full consistency:

In `data/ui/properties.ui`:
- `button_properties_os_translator` → `button_properties_os_compat_layer`
- `button_properties_isa_translator` → `button_properties_isa_compat_layer`

Then in `minigalaxy/ui/properties.py` update template children accordingly.

**Corner case:** if any external plugin/theme/automation expects the old widget IDs (unlikely, but possible), renaming IDs could break it. If you want maximum safety, keep IDs and only rename Python variables + user-visible text.

---

## Alternatives (if the above is too risky / too big for one PR)

### Alternative 1 (lowest risk, fastest): only rename user-visible strings + comments
- Leave code identifiers as “translator”
- Only change UI labels/tooltips/docs to say “compatibility layer”

Pros: minimal breakage risk  
Cons: maintainer explicitly asked about code still using “translator”, so this may not satisfy them.

---

### Alternative 2 (middle ground): rename code identifiers but **do not rename persisted keys**
- Keep JSON/config keys: `os_translator_exec`, `translators`, etc.
- Rename only Python symbols:
  - `Translator` class name, variable names, function names, filenames

Pros: avoids data migration complexity  
Cons: still confusing because the stored schema remains “translator”; also you’ll still see it in debugging and saved files.

---

### Alternative 3: do a staged deprecation across releases
**PR 1:** introduce new names + shims, write-both strategy, no removal  
**PR 2 (later):** stop writing old keys (still read them)  
**PR 3 (much later):** remove old keys and shims

Pros: clean long-term, very safe rollout  
Cons: takes longer

---

## Suggested reply to the maintainer (what to comment)
You can reply something like:

> Yes—happy to. I can do a follow-up refactor to switch the internal naming from “translator” to “compatibility layer”. To avoid breaking existing installs, I’ll keep backward compatibility by reading old config/game keys (e.g. `translators`, `game_translators`, `os_translator_exec`, `custom_wine`) and writing both old+new keys for a while. I’ll also keep `translator.py` as a shim that re-exports the renamed classes.

If you want, paste the rest of the repo tree (or at least where `Config.translators` / `translator.py` are used in UI), and I can outline the exact search/replace set and the safest order to land it as separate PRs.